# Аутентификация и Авторизация на Бэкенде

В проекте используется JWT (JSON Web Tokens) для аутентификации пользователей. Реализация включает access токены (короткоживущие) и refresh токены (долгоживущие).

## 1. Ключевые Компоненты

*   **Модели (`backend/shared/models/auth_schemas.py`):**
    *   `LoginRequest`: Для запроса на вход (email, password).
    *   `Token`: Для ответа с токенами (access_token, refresh_token, token_type).
    *   `TokenPayload`: Определяет структуру данных внутри JWT (sub, exp, iat, jti, type, кастомные поля).
    *   `TokenType`: Enum для типов токена (`ACCESS`, `REFRESH`).
    *   `RefreshTokenRequest`: Для запроса на обновление access токена.
*   **Настройки (`backend/shared/config/settings.py`):**
    *   `JWT_SECRET_KEY`: Секретный ключ для подписи токенов. **Критически важно для безопасности!**
    *   `JWT_ALGORITHM`: Алгоритм подписи (например, "HS256").
    *   `ACCESS_TOKEN_EXPIRE_MINUTES`: Время жизни access токена.
    *   `REFRESH_TOKEN_EXPIRE_DAYS`: Время жизни refresh токена.
*   **Утилиты (`backend/shared/utils/security.py`):**
    *   `create_access_token(subject, custom_claims=None)`: Генерирует JWT access токен.
    *   `create_refresh_token(subject)`: Генерирует JWT refresh токен.
    *   `decode_jwt_token(token)`: Декодирует и валидирует токен. Проверяет подпись, время жизни. Возвращает `TokenPayload`.
    *   `verify_password(plain_password, hashed_password)`: Сравнивает пароль с хешем.
    *   `get_password_hash(password)`: Хеширует пароль.
    *   `JWTAuthenticationError`: Пользовательское исключение для ошибок JWT.

## 2. Процесс Аутентификации (Login Flow)

1.  **Запрос Клиента**: Клиент отправляет POST запрос на эндпоинт логина (например, `/api/v1/auth/login`) с `email` и `password` (схема `LoginRequest`).
2.  **Валидация Учетных Данных (`auth_service`):**
    *   Сервис находит пользователя в базе данных по `email`.
    *   Если пользователь найден, его хешированный пароль из БД сравнивается с предоставленным паролем с помощью `verify_password()`.
3.  **Генерация Токенов:**
    *   Если учетные данные верны:
        *   Вызывается `create_access_token(subject=user.id, custom_claims=...)` для создания access токена. `custom_claims` могут включать роли или другие необходимые данные для `TokenPayload`.
        *   Вызывается `create_refresh_token(subject=user.id)` для создания refresh токена.
4.  **Сохранение Refresh Токена (Рекомендуется):**
    *   `jti` (JWT ID) из `TokenPayload` refresh токена (или сам refresh токен, если он не содержит чувствительной информации и хеширован) сохраняется в базе данных (например, в коллекции `active_refresh_tokens` в MongoDB), связываясь с `user_id`. Это позволяет:
        *   Отзывать конкретные refresh токены (logout для одного устройства).
        *   Отзывать все refresh токены пользователя (logout со всех устройств).
        *   Обнаруживать попытки повторного использования уже отозванного refresh токена.
5.  **Ответ Клиенту**: Сервис возвращает `Token` схему, содержащую `access_token` и `refresh_token`.

## 3. Использование Access Токена

1.  **Передача Токена**: Клиент сохраняет `access_token` (например, в памяти JavaScript или безопасном хранилище) и включает его в заголовок `Authorization` каждого запроса к защищенным эндпоинтам:
    ```
    Authorization: Bearer <your_access_token>
    ```
2.  **Валидация на Бэкенде (FastAPI Dependency):**
    *   Для защищенных эндпоинтов используется зависимость (например, `Depends(get_current_user)`).
    *   Эта зависимость извлекает токен из заголовка.
    *   Вызывает `decode_jwt_token(token)`.
    *   Если токен валиден и `payload.type == TokenType.ACCESS`:
        *   Из `payload.sub` (user_id) извлекается информация о пользователе (например, запрос к БД).
        *   Пользователь (или его ID/модель) передается в эндпоинт.
    *   Если токен невалиден (просрочен, неверная подпись, неверный тип), `decode_jwt_token` вызовет `JWTAuthenticationError`, которое будет перехвачено обработчиком исключений FastAPI и вернет клиенту ошибку `401 Unauthorized`.

## 4. Обновление Access Токена (Refresh Flow)

1.  **Истечение Access Токена**: Когда `access_token` истекает, клиент получает ошибку `401 Unauthorized`.
2.  **Запрос на Обновление**: Клиент отправляет POST запрос на эндпоинт обновления (например, `/api/v1/auth/refresh`) с `refresh_token` (схема `RefreshTokenRequest`).
3.  **Валидация Refresh Токена (`auth_service`):**
    *   Вызывается `decode_jwt_token(refresh_token)`.
    *   Проверяется, что `payload.type == TokenType.REFRESH`.
    *   **Проверка отзыва**: Сервис проверяет, не был ли этот refresh токен отозван (сверяясь с БД по `jti` или `sub`). Если отозван, возвращается ошибка `401`.
4.  **Генерация Новых Токенов:**
    *   Если refresh токен валиден и не отозван:
        *   Создается новый `access_token` для `payload.sub`.
        *   **Опционально (рекомендуется для безопасности - Refresh Token Rotation):** Создается новый `refresh_token`. Старый refresh токен (чей `jti` использовался для запроса) инвалидируется/удаляется из БД, а новый сохраняется. Это усложняет злоумышленнику использование украденного refresh токена.
5.  **Ответ Клиенту**: Сервис возвращает `Token` схему с новым `access_token` (и, возможно, новым `refresh_token`). Клиент обновляет свои сохраненные токены.

## 5. Выход из Системы (Logout)

*   **Клиентская сторона**: Клиент должен удалить `access_token` и `refresh_token` из своего хранилища.
*   **Серверная сторона (если refresh токены отслеживаются):**
    *   Клиент может отправить запрос на специальный эндпоинт logout.
    *   Сервис инвалидирует/удаляет текущий refresh токен пользователя из БД (тот, который был бы использован для следующего обновления, или все токены пользователя).
*   Access токен останется технически валидным до истечения своего срока (`exp`), но без refresh токена новый access токен получить будет нельзя. Для немедленной инвалидации access токенов потребовалась бы более сложная система с черным списком (например, в Redis), что усложняет архитектуру.

## 6. Безопасность JWT

*   **Используйте HTTPS**: Всегда передавайте токены только через HTTPS.
*   **Короткое время жизни Access Токенов**: Минимизирует ущерб от утечки.
*   **Безопасное хранение Refresh Токенов**: 
    *   На клиенте: в `HttpOnly` cookie (если фронтенд и бэкенд на одном домене/поддоменах и настроен CSRF-защита) или в безопасном хранилище приложения (для мобильных приложений). Избегайте `localStorage` для JWT, так как он уязвим для XSS.
    *   На сервере: отслеживайте и позволяйте отзывать refresh токены.
*   **Не храните чувствительные данные в Payload**: JWT подписаны, но не зашифрованы по умолчанию.
*   **Секретный ключ (`JWT_SECRET_KEY`)**: Должен быть сложным, уникальным и надежно храниться (не в коде для продакшена).
*   **Refresh Token Rotation**: Повышает безопасность, инвалидируя использованные refresh токены. 